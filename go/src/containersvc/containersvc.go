/*
Package containersvc implements utility functions to control docker containers
running as a service/daemon.

Copyright (c) 2017 Nutanix Inc. All rights reserved.

Author: rohith.subramanyam@nutanix.com

Usage:
	package main

	import (
		"fmt"

		"containersvc"
	)

	// main starts a container.
	func main() {
		if err := containersvc.Start("/tmp/hello-world.tar",
			"hello-world", &containersvc.Config{}); err != nil {

			fmt.Println(err)
		}
	}

	// main checks status of container and stops container.
	func main() {
		if err := containersvc.Status("hello-world", ""); err != nil {
			fmt.Println(err)
		}
		if err := containersvc.Stop("hello-world", "",
			false); err != nil {

				fmt.Println(err)
		}
	}
*/
package containersvc

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/cli/command"
	"github.com/docker/docker/client"
	"github.com/docker/docker/opts"
	"github.com/docker/docker/pkg/jsonmessage"
	"github.com/docker/go-connections/nat"
	"github.com/golang/glog"
	"golang.org/x/net/context"
)

// ContainerSvcV is the containersvc API version.
const ContainerSvcV = "1.0.0"

// RestartPolicyEnum implements the valid Docker restart policies.
type RestartPolicyEnum string

// String implements the String function of flags.Value interface so that it can
// be used as a flag in the client.
func (rpe *RestartPolicyEnum) String() string {
	return string(*rpe)
}

// Set implements the Set function of flags.Value interface so that it can be
// used as a flag in the client.
func (rpe *RestartPolicyEnum) Set(value string) error {
	*rpe = RestartPolicyEnum(value)

	return nil
}

// Docker container restart policies.
const (
	// No: do not automatically restart the container when it exits. This is
	// the default.
	No RestartPolicyEnum = "no"
	// OnFailure: restart only if the container exits with a non-zero exit
	// status.
	OnFailure = "on-failure"
	// UnlessStopped: container will automatically restart unless user has
	// put it to stopped state.
	UnlessStopped = "unless-stopped"
	// Always: always restart the container regardless of the exit status.
	// When you specify always, the Docker daemon will try to restart the
	// container indefinitely. The container will also always start on
	// daemon startup, regardless of the current state of the container.
	Always = "always"
)

// Config encapsulates docker container options.
type Config struct {
	// Name of the container.
	CtrName string
	// Port mapping between the exposed port (container) and the host.
	PortMap map[string]string
	// Name of the volume driver used to mount volumes.
	VolumeDriver string
	// List of volumes (mounts) used for the container.
	Volumes []string
	// Run the container in the background.
	Background bool
	// Restart policy to be used for the container.
	RestartPolicy RestartPolicyEnum
	// Automatically remove container when it exits.
	AutoRemove *bool
	// Log the logs generated by the container.
	Log bool
	// The Tty and OpenStding Config options allocate a pseudo-tty and keep
	// stdin open even if not attached. This will allow you to use the
	// container like a traditional VM as long as the bash prompt is
	// running.
	// Keep stdin open even if not attached.
	OpenStdin *bool
	// Attach standard streams to a tty, including stdin if it is not
	// closed.
	Tty *bool
	// Allow only one container instance to be running per image.
	OnlyOneContainerInstancePerImage bool
}

// Start loads the docker image from imgPath and starts a container of the image
// img, if successful.
// It returns an error on failure.
// img can either be the image name or image ID. If img is an image name, it
// must be the name of imgPath docker image.
// Equivalent to the following commands:
// 	$ systemctl start docker-latest.service
// 	$ docker load -i imgPath
// 	$ docker run [-i] [-t] [-d] [--name=cfg.CtrName] [-p 127.0.0.1:80:8080]
// 		[--volume-driver=cfg.VolumeDriver] [-v ntnx_test:/data] [--rm]
// 		[--restart=cfg.RestartPolicy] img
// -i, -t, -d, --rm options are enabled depending on the following bool values
// in cfg respectively: OpenStdin, Background, AutoRemove.
// The port mappings passed to -p should be passed as cfg.PortMap. The volumes
// passed to -v should be passed as cfg.Volumes.
func Start(imgPath, img string, cfg *Config) error {
	glog.Infof("Starting a container of image %s loaded from %s", img,
		imgPath)

	cfg = defCfg(cfg)

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), imgPath, img)

	if err := startDockerD(); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	cli, err := newClient()
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer func() {
		if err := cli.Close(); err != nil {
			glog.Warning(err)
		}
	}()

	ctx := context.Background()

	if err := imageLoad(ctx, cli, imgPath); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	if err := start(ctx, cli, img, cfg); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// Status logs the status of running container(s) whose image is img and name is
// ctrName, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker ps [-f ancestor=img] [-f name=ctrName]
func Status(img, ctrName string) error {
	glog.Infof("Getting Status of container %s, image %s", ctrName, img)

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), img, ctrName)

	cli, err := newClient()
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer func() {
		if err := cli.Close(); err != nil {
			glog.Warning(err)
		}
	}()

	ctx := context.Background()

	if err := status(ctx, cli, img, ctrName); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// Stop stops the container(s) started by the same calling client whose image is
// img and name is ctrName, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker stop $(docker ps -q [-f ancestor=img] [-f name=ctrName])
// If force is true, it does not restrict itself to stopping container(s)
// started by the same calling client.
func Stop(img, ctrName string, force bool) error {
	glog.Infof("Stopping container %s, image %s", ctrName, img)

	if !force && !started {
		// This is to ensure that this does not kill a container started
		// by another instance of the client. However, if force is true,
		// it just works as a normal Stop API killing any container(s)
		// whose image is img and container name is ctrName.
		glog.Info("No container started by the client to be stopped")
		return nil
	}

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), img, ctrName)

	cli, err := newClient()
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer func() {
		if err := cli.Close(); err != nil {
			glog.Warning(err)
		}
	}()

	ctx := context.Background()

	if err := stop(ctx, cli, img, ctrName); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// Log logs the logs generated by container(s) whose image is img and name is
// ctrName, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker log -t --details $(docker ps -q [-f ancestor=img]
// 		[-f name=ctrName])
func Log(img, ctrName string) error {
	glog.Infof("Logging logs generated by container %s, image %s", ctrName,
		img)

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), img, ctrName)

	cli, err := newClient()
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer func() {
		if err := cli.Close(); err != nil {
			glog.Warning(err)
		}
	}()

	ctx := context.Background()

	ctrs, err := list(ctx, cli, img, ctrName, "", false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	for _, ctr := range ctrs {
		var logPrefix string
		if len(ctrName) > 0 {
			logPrefix = ctrName
		} else {
			logPrefix = img
		}
		if err := log(ctx, cli, ctr.ID, logPrefix); err != nil {
			return fmt.Errorf("%s %s", errP, err)
		}
	}

	return nil
}

// PPrint returns a pretty string in JSON format of an interface with indents if
// indent is true, if successful.
// It returns its value in default format (with field names in case of structs)
// in case of a failure.
func PPrint(tbp interface{}, indent bool) string {
	if glog.V(3) {
		glog.Infof("Pretty printing %+v. Indent: %t", tbp, indent)
	}

	// Error prefix.
	errP := fmt.Sprintf("%s %+v %t:", fn(), tbp, indent)

	if indent {
		pJSON, err := json.MarshalIndent(tbp, "", "  ")
		if err != nil {
			glog.Warningf("%s %s", errP, err)
			return fmt.Sprintf("%+v", tbp)
		}

		return string(pJSON)
	}

	pJSON, err := json.Marshal(tbp)
	if err != nil {
		glog.Warningf("%s %s", errP, err)
		return fmt.Sprintf("%+v", tbp)
	}

	return string(pJSON)
}

const cliAPIV = "v1.26" // Docker API client version.
var cli *client.Client  // Cached docker client.

// newClient returns a docker client with version cliAPIV, if successful.
// It returns an error on failure.
// It returns a cached version of the client, if it is already created by the
// same process.
func newClient() (*client.Client, error) {
	if glog.V(2) {
		glog.Infof("Getting docker client")
	}

	// Error prefix.
	errP := fmt.Sprintf("%s:", fn())

	if cli != nil {
		if glog.V(2) {
			glog.Infof("Returning cached docker client: %+v", cli)
		}
		return cli, nil
	}

	if glog.V(2) {
		glog.Info("Creating new docker client")
	}

	custHdrs := map[string]string{}
	custHdrs["User-Agent"] = command.UserAgent()

	// Passing the version explicitly so that client does not break if the
	// server is upgraded.
	// Passing nil for the http client to let the api client configure the
	// default transport.
	var err error
	cli, err = client.NewClient(opts.DefaultHost, cliAPIV, nil, custHdrs)
	if err != nil {
		return nil, fmt.Errorf("%s %s", errP, err)
	}

	return cli, nil
}

// defCfg assigns default values to attributes of cfg that are not set by the
// client and returns it.
func defCfg(cfg *Config) *Config {
	if glog.V(2) {
		glog.Infof("Assigning default values in config: %s",
			PPrint(cfg, true))
	}

	if len(cfg.RestartPolicy) == 0 {
		cfg.RestartPolicy = No
	}
	if cfg.Tty == nil {
		tty := true
		cfg.Tty = &tty
	}
	if cfg.OpenStdin == nil {
		openStdin := true
		cfg.OpenStdin = &openStdin
	}
	if cfg.AutoRemove == nil {
		autoRemove := true
		cfg.AutoRemove = &autoRemove
	}

	glog.Infof("Using containsersvc config: %s", PPrint(cfg, true))

	return cfg
}

// startDockerD starts the docker-latest systemd service if it is not already
// started, if successful.
// It returns an error on failure.
// It is a no-op if the docker service is already running.
// It is equivalent to the following command:
// 	$ sudo systemctl start docker-latest.service
func startDockerD() error {
	glog.Info("Starting docker daemon if not already started")

	// Error prefix.
	errP := fmt.Sprintf("%s:", fn())

	err := exec.Command("sudo", "systemctl", "start",
		"docker-latest.service").Run()
	// systemctl does not print anything to stdout on start.
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// imageLoad loads the docker image from imgPath, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker load -i imgPath
func imageLoad(ctx context.Context, cli *client.Client, path string) error {
	glog.Info("Loading image from ", path)

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), path)

	image, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer image.Close()

	resp, err := cli.ImageLoad(ctx, image, false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			glog.Warning(err)
		}
	}()

	if resp.Body != nil && resp.JSON {
		// Streams image loading progress to stdout.
		return jsonmessage.DisplayJSONMessagesToStream(resp.Body,
			command.NewOutStream(os.Stdout), nil)
	}
	responseBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		glog.Warning(err)
		return nil // Return nil since loading image succeeded anyway.
	}
	glog.Info(string(responseBody))

	return nil
}

// runMode returns the string "background"/"foreground" depending on how the
// client has configured the container.
func runMode(ctx context.Context, cfg *Config) string {
	if cfg.Background {
		return "background"
	}

	return "foreground"
}

// Used to remove containers started in background during stop.
var (
	bg     bool // Container started in background.
	autoRm bool // Container configured to be auto removed.
)
var started bool // Container successfully started.by me.

// start starts a container of the image img, if successful.
// It returns an error on failure.
// img can either be the image name or image ID. If img is an image name, it
// must be the name of imgPath docker image.
// Equivalent to the following docker command:
// 	$ docker run [-i] [-t] [-d] [--name=cfg.CtrName] [-p 127.0.0.1:80:8080]
// 		[--volume-driver=cfg.VolumeDriver] [-v ntnx_test:/data] [--rm]
// 		[--restart=cfg.RestartPolicy] img
// -i, -t, -d, --rm options are enabled depending on the following bool values
// in cfg respectively: OpenStdin, Background, AutoRemove.
// The port mappings passed to -p should be passed as cfg.PortMap. The volumes
// passed to -v should be passed as cfg.Volumes.
func start(ctx context.Context, cli *client.Client, img string,
	cfg *Config) error {

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), img)

	resp, err := create(ctx, cli, img, cfg)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	glog.Infof("Starting container %s of image %s in the %s", resp.ID, img,
		runMode(ctx, cfg))

	if err := cli.ContainerStart(ctx, resp.ID,
		types.ContainerStartOptions{}); err != nil {

		return fmt.Errorf("%s %s", errP, err)
	}

	started = true

	if cfg.Background {
		bg = true
		autoRm = true

		return nil
	}

	glog.Infof("Waiting for container %s of image %s to exit...", resp.ID,
		img)

	// Running the container in the foreground.
	if _, err = cli.ContainerWait(ctx, resp.ID); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	glog.Infof("Container %s of image %s exited", resp.ID, img)

	if cfg.Log {
		var logPrefix string
		if len(cfg.CtrName) > 0 {
			logPrefix = cfg.CtrName
		} else {
			logPrefix = img
		}

		log(ctx, cli, resp.ID, logPrefix)
	}

	// The HostConfig attribute AutoRemove: true does not work for this
	// version of the API.
	if *cfg.AutoRemove {
		if err := remove(ctx, cli, resp.ID); err != nil {
			return fmt.Errorf("%s %s", errP, err)
		}
	}

	return nil
}

// create creates and returns a container of the image img, if successful.
// img is either the image name or image ID.
// It returns an error on failure.
// img can either be the image name or image ID. If img is an image name, it
// must be the name of imgPath docker image.
// Equivalent to the following docker command:
// 	$ docker create [-i] [-t] [-d] [--name=cfg.CtrName]
// 		[-p 127.0.0.1:80:8080] [--volume-driver=cfg.VolumeDriver]
// 		[-v ntnx_test:/data] [--rm] [--restart=cfg.RestartPolicy] img
// -i, -t, -d, --rm options are enabled depending on the following bool values
// in cfg respectively: OpenStdin, Background, AutoRemove.
// The port mappings passed to -p should be passed as cfg.PortMap. The volumes
// passed to -v should be passed as cfg.Volumes.
func create(ctx context.Context, cli *client.Client, img string, cfg *Config) (
	resp container.ContainerCreateCreatedBody, rErr error) {

	glog.Infof("Creating a container from image %s", img)

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), img)

	if cfg.OnlyOneContainerInstancePerImage {
		if rErr = onlyOneCtrInstancePerImg(ctx, cli, img); rErr != nil {
			rErr = fmt.Errorf("%s %s", errP, rErr)
			return
		}
	}

	// Get docker's port config to be passed as part of HostConfig.
	portBindings, portSet, err := getPortConfig(cfg.PortMap)
	if err != nil {
		rErr = fmt.Errorf("%s %s", errP, err)
		return
	}

	// Removed thirdparty/go-pkgs/go/src/github.com/docker/docker/vendor/
	// github.com/docker/go-connections/nat directory to circumvent the open
	// issue in docker:
	// github.com/moby/moby/issues/29362, github.com/moby/moby/issues/28269
	// TODO: git clone the entire docker github to get the dir back once the
	// above issue is fixed by docker.
	resp, rErr = cli.ContainerCreate(
		ctx,
		&container.Config{
			ExposedPorts: portSet,
			Tty:          *cfg.Tty,
			OpenStdin:    *cfg.OpenStdin, Image: img},
		&container.HostConfig{
			Binds:        cfg.Volumes,
			PortBindings: portBindings,
			RestartPolicy: container.RestartPolicy{
				Name: string(cfg.RestartPolicy)},
			AutoRemove:   *cfg.AutoRemove,
			VolumeDriver: cfg.VolumeDriver},
		nil,
		cfg.CtrName)

	if rErr != nil {
		if strings.Contains(rErr.Error(),
			"Conflict. The container name") {
			// Error response from daemon: {"message":"Conflict. The
			// container name \"/hello-world\" is already in use by
			// container 23949e22b9e75e35bd1860bea955ab3c374c2a2148b
			// 6a55f5d0c833fd3d9683e. You have to remove (or rename)
			// that container to be able to reuse that name."}
			if rErr = maybeRmNamesakeCtr(ctx, cli, cfg.CtrName,
				rErr.Error()); rErr != nil {

				rErr = fmt.Errorf("%s %s", errP, rErr)
				return
			}
			// Try again now that containers are removed.
			return create(ctx, cli, img, cfg)
		}
		rErr = fmt.Errorf("%s %s", errP, rErr)
		glog.Error(rErr)

		return
	}

	glog.Info("Created container ", resp.ID)

	return
}

// onlyOneCtrInstancePerImg checks if only one container instance of the image
// img is running. If this is not true, it returns an error.
func onlyOneCtrInstancePerImg(ctx context.Context, cli *client.Client,
	img string) error {

	glog.Infof("Ensuring no container instance of image %s is already "+
		"running", img)

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), img)

	ctrs, err := list(ctx, cli, img, "", "", false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	if len(ctrs) > 0 {
		err := fmt.Errorf("%s only one container instance can be "+
			"running for image %s", errP, img)
		glog.Errorf("%s. Already running:", err)
		for _, ctr := range ctrs {
			glog.Error(PPrint(ctr, true))
		}
		return err
	}

	return nil
}

// getPortConfig returns docker's nat.PortMap from the client port
// configuration: portMap, if successful.
// It returns an error on failure.
func getPortConfig(portMap map[string]string) (portBindings nat.PortMap,
	portSet nat.PortSet, rErr error) {

	if glog.V(2) {
		glog.Infof("Building docker's port config from client's port "+
			"config %s", PPrint(portMap, false))
	}

	// Error prefix.
	errP := fmt.Sprintf("%s:", fn())

	if portMap == nil {
		return
	}

	portBindings = make(nat.PortMap)
	portSet = make(nat.PortSet)

	for hostPort, ctrPort := range portMap {
		host, port, err := net.SplitHostPort(hostPort)
		if err != nil {
			if strings.Contains(err.Error(),
				"missing port in address") {
				host = ""
				port = hostPort
			} else {
				rErr = fmt.Errorf("%s invalid host port "+
					"format: %s. Error: %s", errP, hostPort,
					err)
				return
			}
		}
		ctrPortProto, err := nat.NewPort("tcp", ctrPort)
		if err != nil {
			rErr = fmt.Errorf("%s invalid port format: %s. Error:"+
				" %s", errP, ctrPort, err)
			return
		}
		portBindings[ctrPortProto] = []nat.PortBinding{
			nat.PortBinding{HostIP: host, HostPort: port}}
		portSet[ctrPortProto] = struct{}{}
	}

	return
}

// maybeRmNamesakeCtr checks the error of the docker ContainerCreate API and if
// the error is due to container name conflicts, it removes the container of the
// same name if it is not running, if successful.
// It returns an error on failure and for other errors of ContainerCreate.
func maybeRmNamesakeCtr(ctx context.Context, cli *client.Client, ctrName string,
	errMsg string) error {

	glog.Info("Maybe removing namesake container of ", ctrName)
	glog.Warning(errMsg)

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), ctrName)

	// Get the ID which is 64 character long alphanumeric string.
	re := regexp.MustCompile("\\w{64}")
	matches := re.FindAllString(errMsg, -1)
	if len(matches) == 0 {
		return fmt.Errorf("%s No docker ID found in %s", errP, errMsg)
	}
	// Get the rightmost match since container name can also have 64 chars.
	ctrID := matches[len(matches)-1]
	glog.Infof("Namesake container ID: %s", ctrID)

	ctrs, err := list(ctx, cli, "", "", ctrID, false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	if len(ctrs) == 0 {
		glog.Infof("Container %s not running. Removing it", ctrID)

		// Log the container details.
		ctrs, err := list(ctx, cli, "", "", ctrID, true)
		if err != nil {
			return fmt.Errorf("%s %s", errP, err)
		}
		for _, ctr := range ctrs {
			glog.Info(PPrint(ctr, true))
		}

		if err := remove(ctx, cli, ctrID); err != nil {
			return fmt.Errorf("%s %s", errP, err)
		}
		return nil
	}
	// Container with same name is running.
	msg := fmt.Sprintf("Another container with same name %s is already "+
		"running", ctrID)
	glog.Error(msg)
	for _, ctr := range ctrs {
		glog.Error(PPrint(ctr, true))
	}

	return fmt.Errorf("%s %s", errP, msg)
}

// list returns the list of container(s) whose image is img and name is ctrName,
// if successful.
// It returns an error on failure.
// If all is false, it shows only running containers.
// Equivalent to the following docker command:
// 	$ docker ps [-a] [-f ancestor=img] [-f name=ctrName]
func list(ctx context.Context, cli *client.Client, img, ctrName, ctrID string,
	all bool) ([]types.Container, error) {

	glog.Infof("Listing containers with name %s, ID %s, image %s. All: %t",
		ctrName, ctrID, img, all)

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s %s %t:", fn(), img, ctrName, ctrID, all)

	filterArgs := filters.NewArgs()
	if len(img) > 0 {
		filterArgs.Add("ancestor", img)
	}
	if len(ctrName) > 0 {
		filterArgs.Add("name", ctrName)
	}
	if len(ctrID) > 0 {
		filterArgs.Add("id", ctrID)
	}

	ctrs, err := cli.ContainerList(ctx, types.ContainerListOptions{
		Filters: filterArgs, All: all})
	if err != nil {
		return nil, fmt.Errorf("%s %s", errP, err)
	}

	if glog.V(2) {
		for _, ctr := range ctrs {
			glog.Info(PPrint(ctr, true))
		}
	}

	return ctrs, nil
}

// remove removes the container with ID ctrID, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker rm ctrID
func remove(ctx context.Context, cli *client.Client, ctrID string) error {
	glog.Infof("Removing container %s", ctrID)

	// Error prefix.
	errP := fmt.Sprintf("%s %s:", fn(), ctrID)

	if err := cli.ContainerRemove(ctx, ctrID, types.ContainerRemoveOptions{
		RemoveVolumes: false}); err != nil {

		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// status logs the status of running container(s) whose image is img and name is
// ctrName, if successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker ps [-f ancestor=img] [-f name=ctrName]
func status(ctx context.Context, cli *client.Client, img,
	ctrName string) error {

	if glog.V(2) {
		glog.Infof("Getting status of container %s, image %s", ctrName,
			img)
	}

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), img, ctrName)

	ctrs, err := list(ctx, cli, img, ctrName, "", false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	for _, ctr := range ctrs {
		glog.Info(PPrint(ctr, true))
	}

	return nil
}

// stop stops the container(s) whose image is img and name is ctrName, if
// successful.
// It returns an error on failure.
// Equivalent to the following docker command:
// 	$ docker stop $(docker ps -q [-f ancestor=img] [-f name=ctrName])
func stop(ctx context.Context, cli *client.Client, img, ctrName string) error {
	if glog.V(2) {
		glog.Infof("stopping container %s, image %s", ctrName, img)
	}

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), img, ctrName)

	ctrs, err := list(ctx, cli, img, ctrName, "", false)
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}
	for _, ctr := range ctrs {
		glog.Infof("Stopping container: %s", PPrint(ctr, true))
		if err := cli.ContainerStop(ctx, ctr.ID, nil); err != nil {
			return fmt.Errorf("%s %s %s", errP, ctr.ID, err)
		}

		if bg && autoRm {
			glog.Infof("Removing container %s %s that was started "+
				"in background mode", ctr.Names, ctr.ID)
			if err := remove(ctx, cli, ctr.ID); err != nil {
				glog.Warning(err)
			}
		}
	}

	return nil
}

// log logs the logs generated by the container ctrID.
// Equivalent to the following docker command:
// 	docker log -t --details ctrID
func log(ctx context.Context, cli *client.Client, ctrID,
	logPrefix string) error {

	glog.Infof("Logging container %s %s logs:", logPrefix, ctrID)

	// Error prefix.
	errP := fmt.Sprintf("%s %s %s:", fn(), ctrID, logPrefix)

	ctxTo, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	out, err := cli.ContainerLogs(ctxTo, ctrID,
		types.ContainerLogsOptions{ShowStdout: true,
			ShowStderr: true, Timestamps: true, Details: true})
	if err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	scanner := bufio.NewScanner(out)
	for scanner.Scan() {
		glog.Infof("%s: %s", logPrefix, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return fmt.Errorf("%s %s", errP, err)
	}

	return nil
}

// fn returns the function name of the caller.
func fn() string {
	pc, _, _, _ := runtime.Caller(1)
	fn := strings.Split(runtime.FuncForPC(pc).Name(), ".")
	// Just making sure there are no runtime errors.
	if len(fn) < 2 {
		return ""
	}
	// fn will look like: [containersvc start] if this function is being
	// called from within start.
	return fn[len(fn)-1]
}
